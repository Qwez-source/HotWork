### Шанс вопроса: 3%

Написание плохого кода обычно происходит в двух основных ситуациях:

1. **Временное решение**: Когда разработчики сталкиваются с ограниченным временем или неопределенностью будущего, они могут создать код, который решает проблему сейчас, но не учитывает долгосрочную поддержку и улучшение. Это может привести к появлению хакерского кода или кода с низкой читаемостью.

2. **Новичкам в команде**: Когда в команду приходят новички, они могут быть незнакомы с лучшими практиками разработки и создают код, который может быть менее оптимальным или более сложным для понимания.

**Пример временного решения**: Предположим, вам нужно написать программу для чтения данных из файла и выполнения простых операций с ними. Вместо того чтобы создать функциональный и легко расширяемый код, можно написать скрипт, который работает только для текущего формата данных или конкретной задачи. Это может привести к проблемам в будущем, если потребуется поддержка другого формата или изменить логику обработки данных.

**Пример кода плохого кода**:
```python
# Плохой код: чтение и обработка данных из файла
def read_data(file_path):
    data = []
    with open(file_path, 'r') as file:
        for line in file:
            # Предположим, что каждая строка содержит число
            data.append(int(line.strip()))
    return sum(data)  # Возвращает сумму всех чисел в файле
```
Этот код плохой, потому что он предполагает, что каждая строка файла содержит число, и не обрабатывает возможные ошибки ввода-вывода или форматирования данных. В будущем, если потребуется поддержка других форматов или более сложная обработка данных, придется переписывать весь код.

**Пример для новичков в команде**: Команда только что наняла группу разработчиков, которые не имеют опыта работы с Python или другими языками программирования. Они могут начать с простого и понятного решения задачи, но без учета будущих расширений и улучшений.

**Пример кода плохого кода**:
```python
# Плохой код: отсутствие функциональности и избыточность
def process_data(data):
    result = []
    for item in data:
        if isinstance(item, int) or isinstance(item, float):
            result.append(item * 2)
        else:
            # Обработка нечисловых данных (плохое решение)
            continue
    return result

data = [1, 2, 'three', 4]
processed_data = process_data(data)
```
Этот код плохой, потому что он не обрабатывает нечисловые данные должным образом и предполагает, что все данные являются числами. В будущем потребуется добавить проверку типов данных или обработку ошибок для обеспечения устойчивости кода.