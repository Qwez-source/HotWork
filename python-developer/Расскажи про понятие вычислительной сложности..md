### Шанс вопроса: 3%

Вычислительная сложность — это концепция, которая оценивает, сколько времени и пространства (памяти) требуется для выполнения алгоритма или программы в зависимости от размера входных данных. Она помогает понять, как быстро алгоритм масштабируется с увеличением объема данных.

### Основные виды вычислительной сложности:
1. **Временная сложность (Time Complexity)**: Оценивает время, необходимое для выполнения алгоритма. Измеряется в количестве шагов или операций, необходимых для завершения работы программы.
2. **Пространственная сложность (Space Complexity)**: Оценивает объем памяти, требуемой для выполнения алгоритма. Измеряется в количестве памяти, используемой переменными и структурами данных.

### Обозначения:
- **O(n)** («О большое от n»): Используется для обозначения верхней границы сложности алгоритма, где `n` — размер входных данных. Например, если временная сложность O(n), это означает, что время выполнения пропорционально размеру входных данных.
- **Ω(n)** («Омега большое от n»): Используется для обозначения нижней границы сложности алгоритма.
- **Θ(n)** («Тета большое от n»): Используется для обозначения точного порядка роста функции, когда время выполнения находится между двумя границами.

### Примеры:
1. **Линейная сложность (O(n))**:
   - Пример алгоритма: Поиск элемента в неотсортированном массиве. В худшем случае, если элемент находится в конце массива, потребуется просмотреть все `n` элементов.
   ```python
   def find_element(arr, x):
       for i in range(len(arr)):
           if arr[i] == x:
               return i
       return -1
   ```

2. **Квадратичная сложность (O(n^2))**:
   - Пример алгоритма: Сортировка пузырьком. Для каждого элемента массива потребуется сравнить и, возможно, обменять его со всеми остальными элементами.
   ```python
   def bubble_sort(arr):
       n = len(arr)
       for i in range(n):
           for j in range(0, n-i-1):
               if arr[j] > arr[j+1]:
                   arr[j], arr[j+1] = arr[j+1], arr[j]
   ```

3. **Логарифмическая сложность (O(log n))**:
   - Пример алгоритма: Бинарный поиск в отсортированном массиве. Каждый шаг уменьшает область поиска вдвое, что приводит к логарифмическому времени выполнения.
   ```python
   def binary_search(arr, low, high, x):
       if high >= low:
           mid = (high + low) // 2
           if arr[mid] == x:
               return mid
           elif arr[mid] > x:
               return binary_search(arr, low, mid - 1, x)
           else:
               return binary_search(arr, mid + 1, high, x)
       else:
           return -1
   ```

### Заключение:
Вычислительная сложность является важным аспектом разработки алгоритмов и программ. Она помогает оценить производительность и масштабируемость решения, что особенно важно при работе с большими объемами данных или в реальном времени.