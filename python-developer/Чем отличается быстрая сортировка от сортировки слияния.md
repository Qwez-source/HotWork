### Шанс вопроса: 3%

Быстрая сортировка (QuickSort) и сортировка слиянием (Merge Sort) — это два распространенных алгоритма сортировки, каждый из которых имеет свои преимущества и недостатки. Вот основные различия между ними:

1. **Принцип работы**:
   - **Быстрая сортировка**: Алгоритм использует стратегию "разделяй и властвуй". Он выбирает опорный элемент (обычно последний элемент в массиве), после чего перемещает все меньшие элементы влево, а большие — вправо. После этого рекурсивно применяется к подмассивам слева и справа от опорного элемента.
   - **Сортировка слиянием**: Алгоритм также использует стратегию "разделяй и властвуй". Он делит массив на две равные (или почти равные) части, сортирует каждую из них независимо и затем объединяет отсортированные части.

2. **Эффективность**:
   - **Быстрая сортировка**: Имеет среднюю временную сложность O(n log n), что делает её очень эффективной для большинства задач. Однако, в худшем случае (например, при неудачном выборе опорного элемента) может достигать O(n^2).
   - **Сортировка слиянием**: Также имеет среднюю временную сложность O(n log n), что делает её стабильно быстрой. Однако, она требует дополнительного пространства для хранения временных массивов при слиянии.

3. **Устойчивость к данным**:
   - **Быстрая сортировка**: Не является устойчивой (не сохраняет относительный порядок равных элементов).
   - **Сортировка слиянием**: Является устойчивой, что важно для сохранения исходного порядка равных элементов.

4. **Реализация**:
   Пример реализации быстрой сортировки на Python:
   ```python
   def quicksort(arr):
       if len(arr) <= 1:
           return arr
       pivot = arr[-1]
       left = [x for x in arr[:-1] if x < pivot]
       right = [x for x in arr[:-1] if x >= pivot]
       return quicksort(left) + [pivot] + quicksort(right)

   # Пример использования
   arr = [3, 6, 8, 10, 1, 2, 1]
   print(quicksort(arr))
   ```

   Пример реализации сортировки слиянием на Python:
   ```python
   def merge_sort(arr):
       if len(arr) <= 1:
           return arr
       mid = len(arr) // 2
       left_half = merge_sort(arr[:mid])
       right_half = merge_sort(arr[mid:])
       return merge(left_half, right_half)

   def merge(left, right):
       merged = []
       i, j = 0, 0
       while i < len(left) and j < len(right):
           if left[i] < right[j]:
               merged.append(left[i])
               i += 1
           else:
               merged.append(right[j])
               j += 1
       merged.extend(left[i:])
       merged.extend(right[j:])
       return merged

   # Пример использования
   arr = [3, 6, 8, 10, 1, 2, 1]
   print(merge_sort(arr))
   ```

В целом, выбор между быстрой и сортировкой слиянием зависит от конкретных требований к производительности, пространству и устойчивости. Для большинства случаев, учитывая их эффективность и простоту реализации, быстрая сортировка является предпочтительным выбором.