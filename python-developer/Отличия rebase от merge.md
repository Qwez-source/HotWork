### Шанс вопроса: 10%

`rebase` и `merge` — это два основных способа интеграции изменений между ветками в системах контроля версий, таких как Git. Вот основные отличия между ними:

1. **Цель**:
   - **Merge**: Целью `merge` является объединение двух или более историй разработки в одну ветку. Это создаёт новый коммит, который представляет собой слияние всех изменений из других веток.
   - **Rebase**: Целью `rebase` является применение последовательности коммитов из одной ветки к другой. Это позволяет создать линейное истории разработки, делая их более понятными и чистыми.

2. **История коммитов**:
   - **Merge**: При `merge` история коммитов остаётся относительно неизменной в главной ветке, так как создаётся новый коммит, представляющий слияние. Это может привести к появлению избыточных коммитов.
   - **Rebase**: При `rebase` история коммитов в главной ветке становится линейной, так как все коммиты переносятся и повторно применяются на вершине новой базы. Это делает историю более чистой и понятной.

3. **Конфликты**:
   - **Merge**: При `merge` возможны конфликты, если одна и та же часть файла была изменена в обеих ветках. Конфликты необходимо разрешить вручную после слияния.
   - **Rebase**: Во время `rebase` могут возникать конфликты по тем же причинам, что и при merge, но они обрабатываются на этапе каждого перебазирования коммита, позволяя разрешать их локально.

4. **Идеология**:
   - **Merge**: `merge` поддерживает идею о том, что все изменения должны оставаться в истории проекта.
   - **Rebase**: `rebase` может нарушать эту идеологию, так как он переписывает историю коммитов, создавая иллюзию, что изменения были сделаны на более ранней стадии.

Пример использования `merge`:
```sh
git checkout main
git merge feature-branch
```

Пример использования `rebase`:
```sh
git checkout feature-branch
git rebase main
```

В целом, `merge` является более безопасным и предсказуемым способом объединения изменений, в то время как `rebase` позволяет создать более линейное дерево коммитов, но требует большего контроля при работе с историей проекта.