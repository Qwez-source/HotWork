### Шанс вопроса: 6%

В большинстве современных веб-приложений бизнес-логика обычно отделяется от представления (frontend) и управления доступом (backend). Это делается для обеспечения модульности, масштабируемости и удобства в обслуживании. Где можно хранить бизнес-логику приложения зависит от архитектуры приложения:

1. **Модель данных**: В рамках ORM (Object-Relational Mapping) таких как SQLAlchemy в Python, бизнес-логика может быть интегрирована непосредственно в модели данных. Это позволяет контролировать процессы создания, обновления и удаления данных. Например:
    ```python
    class User(db.Model):
        id = db.Column(db.Integer, primary_key=True)
        username = db.Column(db.String(80), unique=True, nullable=False)

        def save(self):
            db.session.add(self)
            db.session.commit()

        def delete(self):
            db.session.delete(self)
            db.session.commit()
    ```

2. **Сервисы**: В микросервисной архитектуре, бизнес-логика может быть реализована в отдельных сервисах или модулях, которые взаимодействуют с базами данных и другими компонентами системы. Например, у вас есть микросервис для управления заказами, где определены правила расчета стоимости доставки, проверки наличия товаров на складе и т.д.

3. **Сервис-объекты**: В некоторых случаях бизнес-логика может быть реализована в виде сервисных объектов или "служб", которые выполняют определенные задачи. Это позволяет изолировать логику от остальной части приложения:
    ```python
    class OrderService:
        def calculate_total(self, order):
            total = 0
            for item in order.items:
                total += item.price * item.quantity
            if order.customer.is_vip():
                total *= 0.9  # Применяем скидку для VIP-клиентов
            return total
    ```

4. **Репозитории**: В паттерне репозитория, бизнес-логика может быть сосредоточена в объектах репозитория, которые взаимодействуют с базой данных. Это позволяет контролировать доступ к данным и добавлять дополнительную логику:
    ```python
    class UserRepository:
        def get_by_id(self, user_id):
            return User.query.get(user_id)

        def create_user(self, username):
            user = User(username=username)
            db.session.add(user)
            db.session.commit()
            return user
    ```

5. **Бизнес-правила**: В некоторых приложениях бизнес-логика может быть записана в виде правил или политик, которые проверяются перед выполнением определенных действий. Это можно реализовать с помощью библиотек, таких как `pyrules` или собственные настройки:
    ```python
    def validate_user(user):
        if user.age < 18:
            raise ValueError("User must be at least 18 years old")
    ```

Выбор метода зависит от конкретных требований и архитектуры приложения. Важно обеспечить, чтобы бизнес-логика была отделена от представления и управления доступом, что улучшает тестируемость, масштабируемость и поддерживаемость кода.