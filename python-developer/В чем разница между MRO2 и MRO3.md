### Шанс вопроса: 6%

Разницу между MRO (Method Resolution Order) в Python можно понять, рассмотрев два основных метода разрешения порядка наследования: традиционный (MRO1) и C3 линеаризация.

**Tрадиционный MRO (Method Resolution Order)**
Традиционный метод разрешения методов в Python использует следующий алгоритм:
- Сначала выбирается метод из класса, который был определён последним.
- Если таких классов несколько, то порядок выбора зависит от порядка наследования в Python 2.x. В Python 3.x этот метод больше не используется, и вместо него применяется C3 линеаризация.

**Пример:**
```python
class A:
    def method(self):
        print("A")

class B(A):
    pass

class C(A):
    def method(self):
        print("C")

class D(B, C):
    pass

d = D()
d.method()  # Вывод: A (последний класс с методом)
```

**C3 линеаризация (MRO2 и MRO3)**
C3 линеаризация — это алгоритм, который определяет порядок разрешения методов в наследовании. В Python 3 используется именно этот метод для определения порядка разрешения методов (MRO).

**Пример:**
```python
class A:
    def method(self):
        print("A")

class B(A):
    pass

class C(A):
    def method(self):
        print("C")

class D(B, C):
    pass

print(D.mro())  # Вывод: [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>]
```

**Разница:**
- **Tрадиционный MRO**: Непредсказуем и зависит от версии Python, в которой используется. В Python 3 он устарел и заменён на C3 линеаризацию.
- **C3 линеаризация**: Предсказуем и стандартизирован для всех версий Python. Обеспечивает однозначное определение порядка разрешения методов в случае множественного наследования.

Таким образом, традиционный MRO используется только в старых версиях Python и устарел, а современные версии Python (Python 3) используют C3 линеаризацию для определения порядка разрешения методов.