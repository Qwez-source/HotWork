### Шанс вопроса: 13%

Multi-stage builds в Docker позволяют создать более эффективные и чистые образы, уменьшая конечный размер контейнера. Это достигается за счет того, что каждый этап (stage) строится в отдельном контексте сборки, позволяя использовать различные базовые образы и инструменты для каждого этапа. После завершения сборки ненужные инструменты и файлы удаляются, оставляя только финальный продукт.

Пример использования multi stage в Dockerfile:
```dockerfile
# Этап 1: Используем более легкий базовый образ для установки зависимостей
FROM node:14 AS builder
WORKDIR /app
COPY package.json ./
RUN npm install

# Копирование исходного кода приложения
COPY . .

# Сборка приложения
RUN npm run build

# Этап 2: Используем чистый базовый образ для развертывания
FROM nginx:alpine
WORKDIR /usr/share/nginx/html

# Очистка ненужных файлов и копирование собранного приложения из предыдущего этапа
RUN rm -rf ./*
COPY --from=builder /app/build .

# Настройка nginx
COPY nginx.conf /etc/nginx/nginx.conf
```
В этом примере первый этап использует образ Node.js для установки зависимостей и сборки приложения, а второй этап использует чистый образ Nginx для развертывания собранного приложения. Таким образом, в финальном образе остаются только необходимые файлы, что уменьшает его размер и повышает производительность.