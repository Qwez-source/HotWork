### Шанс вопроса: 6%

При завершении работы системы, операционная система посылает сигнал SIGTERM (остановка) процессу. По умолчанию, большинство программ обрабатывают этот сигнал и завершают свою работу в соответствии с планом выхода. Если процесс не реагирует на SIGTERM, операционная система может послать ему дополнительный сигнал SIGKILL (немедленное завершение), который принудительно останавливает процесс без возможности нормального завершения.

SIGKILL не позволяет процессу выполнить какую-либо чистку или сохранение данных перед завершением, что делает его крайне агрессивным по отношению к остальной системе. В результате, если процесс получает SIGKILL, он может порождать зомби-процессы. Зомби-процесс — это завершенный процесс, для которого все ресурсы уже освобождены и сохраненное состояние (например, отладочная информация) хранится в системе; однако родительский процесс зомби-процесса еще не завершен, что приводит к появлению зомби-состояния.

Пример кода на языке C, демонстрирующий принудительное завершение процесса с помощью SIGKILL:
```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void sigHandler(int signum) {
    if (signum == SIGTERM) {
        printf("Received SIGTERM, terminating the process.\n");
        exit(0);
    } else if (signum == SIGKILL) {
        printf("Process killed by SIGKILL.\n");
        exit(0);
    }
}

int main() {
    signal(SIGTERM, sigHandler);
    signal(SIGKILL, sigHandler);

    while (1) {
        sleep(1);
    }
    return 0;
}
```
В этом примере функция `sigHandler` обрабатывает оба сигнала SIGTERM и SIGKILL. Если процесс получает SIGTERM, он завершается нормально; если же он получает SIGKILL, он также принудительно завершается без возможности нормального выхода.